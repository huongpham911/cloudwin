"""
Database Monitoring API for WinCloud Builder
Provides database health, performance, and optimization endpoints
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Dict, List, Any, Optional

from app.api.deps import get_db, require_admin
from app.models.auth_models import User
from app.utils.database_utils import db_optimizer
from app.services.database_service import user_service, droplet_service
import logging

logger = logging.getLogger(__name__)
router = APIRouter()

@router.get("/health", summary="Database Health Check")
async def get_database_health(
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    🏥 Comprehensive database health check
    
    Returns detailed database metrics including:
    - Connection pool status
    - Table statistics  
    - Performance metrics
    - Optimization recommendations
    
    **Requires:** Admin role
    """
    try:
        health_data = db_optimizer.get_database_health(db)
        
        logger.info(f"Database health check performed by admin {admin_user.email}")
        
        return {
            "success": True,
            "timestamp": "now",
            "performed_by": admin_user.email,
            "health_data": health_data
        }
        
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        raise HTTPException(status_code=500, detail=f"Health check failed: {str(e)}")

@router.get("/performance", summary="Database Performance Analysis")
async def analyze_database_performance(
    include_slow_queries: bool = Query(False, description="Include slow query analysis"),
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    📊 Database performance analysis
    
    Analyzes:
    - Query execution times
    - Cache hit ratios
    - Connection metrics
    - Optional slow query analysis
    
    **Requires:** Admin role
    """
    try:
        # Get basic health metrics
        health_data = db_optimizer.get_database_health(db)
        performance_data = health_data.get("performance", {})
        
        result = {
            "success": True,
            "performance_metrics": performance_data,
            "connection_pool": health_data.get("connection_pool", {}),
            "recommendations": health_data.get("recommendations", [])
        }
        
        # Add slow query analysis if requested
        if include_slow_queries:
            slow_queries = db_optimizer.analyze_slow_queries(db)
            result["slow_queries"] = slow_queries
        
        logger.info(f"Database performance analysis performed by admin {admin_user.email}")
        return result
        
    except Exception as e:
        logger.error(f"Database performance analysis failed: {e}")
        raise HTTPException(status_code=500, detail=f"Performance analysis failed: {str(e)}")

@router.get("/optimization/indexes", summary="Index Optimization Suggestions")
async def get_index_suggestions(
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    🔍 Get database index optimization suggestions
    
    Analyzes query patterns and suggests missing indexes
    for improved performance.
    
    **Requires:** Admin role
    """
    try:
        suggestions = db_optimizer.suggest_indexes(db)
        
        logger.info(f"Index suggestions generated by admin {admin_user.email}")
        
        return {
            "success": True,
            "total_suggestions": len(suggestions),
            "index_suggestions": suggestions,
            "note": "Review suggestions carefully before implementing in production"
        }
        
    except Exception as e:
        logger.error(f"Index suggestion generation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Index suggestions failed: {str(e)}")

@router.get("/stats", summary="Database Statistics")
async def get_database_stats(
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    📈 Get comprehensive database statistics
    
    Provides:
    - Table row counts
    - Growth trends
    - Usage patterns
    
    **Requires:** Admin role
    """
    try:
        # Get stats for main models
        user_stats = user_service.get_stats(db)
        droplet_stats = droplet_service.get_stats(db)
        
        # Get table statistics from optimizer
        health_data = db_optimizer.get_database_health(db)
        table_stats = health_data.get("table_stats", {})
        
        result = {
            "success": True,
            "model_statistics": {
                "users": user_stats,
                "droplets": droplet_stats
            },
            "table_statistics": table_stats,
            "database_status": health_data.get("status"),
            "generated_at": "now"
        }
        
        logger.info(f"Database statistics retrieved by admin {admin_user.email}")
        return result
        
    except Exception as e:
        logger.error(f"Database statistics retrieval failed: {e}")
        raise HTTPException(status_code=500, detail=f"Statistics retrieval failed: {str(e)}")

@router.get("/tables/{table_name}/analyze", summary="Analyze Specific Table")
async def analyze_table(
    table_name: str,
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    🔍 Analyze a specific database table
    
    Provides detailed analysis of:
    - Row count and growth
    - Index usage
    - Storage size
    - Query patterns
    
    **Requires:** Admin role
    """
    try:
        # Validate table name (security check)
        allowed_tables = [
            "users", "droplets", "user_sessions", "audit_logs",
            "droplet_regions", "droplet_sizes", "build_progress"
        ]
        
        if table_name not in allowed_tables:
            raise HTTPException(
                status_code=400, 
                detail=f"Table '{table_name}' not allowed. Allowed: {allowed_tables}"
            )
        
        # Get health data for the specific table
        health_data = db_optimizer.get_database_health(db)
        table_stats = health_data.get("table_stats", {}).get(table_name, {})
        
        if not table_stats:
            raise HTTPException(status_code=404, detail=f"Table '{table_name}' not found")
        
        # Get index suggestions for this table
        all_suggestions = db_optimizer.suggest_indexes(db)
        table_suggestions = [s for s in all_suggestions if s.get("table") == table_name]
        
        result = {
            "success": True,
            "table_name": table_name,
            "statistics": table_stats,
            "index_suggestions": table_suggestions,
            "analyzed_by": admin_user.email
        }
        
        logger.info(f"Table '{table_name}' analyzed by admin {admin_user.email}")
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Table analysis failed for '{table_name}': {e}")
        raise HTTPException(status_code=500, detail=f"Table analysis failed: {str(e)}")

@router.post("/maintenance/vacuum", summary="Database Maintenance")
async def perform_database_maintenance(
    analyze: bool = Query(True, description="Run ANALYZE after VACUUM"),
    db: Session = Depends(get_db),
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    🧹 Perform database maintenance operations
    
    Runs:
    - VACUUM to reclaim storage
    - ANALYZE to update statistics
    
    **Note:** Use carefully in production
    **Requires:** Admin role
    """
    try:
        # Only allow for PostgreSQL
        if not db_optimizer.engine.url.drivername.startswith('postgresql'):
            raise HTTPException(
                status_code=400, 
                detail="Maintenance operations only supported for PostgreSQL"
            )
        
        operations_performed = []
        
        # Run VACUUM
        logger.info(f"Starting VACUUM operation requested by {admin_user.email}")
        db.execute("VACUUM")
        operations_performed.append("VACUUM")
        
        # Run ANALYZE if requested
        if analyze:
            logger.info(f"Starting ANALYZE operation requested by {admin_user.email}")
            db.execute("ANALYZE")
            operations_performed.append("ANALYZE")
        
        db.commit()
        
        logger.info(f"Database maintenance completed by admin {admin_user.email}")
        
        return {
            "success": True,
            "operations_performed": operations_performed,
            "performed_by": admin_user.email,
            "message": "Database maintenance completed successfully"
        }
        
    except Exception as e:
        db.rollback()
        logger.error(f"Database maintenance failed: {e}")
        raise HTTPException(status_code=500, detail=f"Maintenance failed: {str(e)}")

@router.get("/connection-pool", summary="Connection Pool Status")
async def get_connection_pool_status(
    admin_user: User = Depends(require_admin)
) -> Dict[str, Any]:
    """
    🔌 Get real-time connection pool status
    
    Shows:
    - Pool size and usage
    - Active connections
    - Connection health
    
    **Requires:** Admin role
    """
    try:
        pool = db_optimizer.engine.pool
        
        pool_status = {
            "pool_size": pool.size(),
            "checked_out_connections": pool.checkedout(),
            "overflow_connections": pool.overflow(),
            "invalid_connections": pool.invalidated(),
            "pool_class": pool.__class__.__name__
        }
        
        # Calculate utilization percentage
        if pool.size() > 0:
            utilization = (pool.checkedout() / pool.size()) * 100
            pool_status["utilization_percent"] = round(utilization, 2)
        
        # Add health assessment
        if pool_status["utilization_percent"] > 80:
            health = "warning"
            message = "High connection pool utilization"
        elif pool_status["invalid_connections"] > 0:
            health = "warning"
            message = "Some connections are invalid"
        else:
            health = "healthy"
            message = "Connection pool is healthy"
        
        logger.info(f"Connection pool status checked by admin {admin_user.email}")
        
        return {
            "success": True,
            "pool_status": pool_status,
            "health": health,
            "message": message,
            "checked_by": admin_user.email
        }
        
    except Exception as e:
        logger.error(f"Connection pool status check failed: {e}")
        raise HTTPException(status_code=500, detail=f"Pool status check failed: {str(e)}")
